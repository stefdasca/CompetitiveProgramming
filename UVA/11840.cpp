/*
        UVA 11840

    Let's use sprague grundy to solve this game. If we have XX. or X.X, those are guaranteed win states and should be dealt with beforehand.

    Otherwise, let's split the input string in intervals separated by crosses and xor the grundy values of the intervals.

    Let's define win[i][j] = grundy value if we have string of length j, which has i crosses at the border. The grundy values can
be computed with mex of the xors of the states generated by adding one X to the eligible positions.


*/
#include<bits/stdc++.h>
#define god dimasi5eks
#pragma GCC optimize("O3")
#define fi first
#define se second
#define pb push_back
#define pf push_front
#define mod 1000000007
#define dancila 3.14159265359
#define eps 1e-9

// #define fisier

using namespace std;

typedef long long ll;

int win[3][10002];
int solve(int mrg, int len)
{
    if(len <= 2)
        return 0;
    if(win[mrg][len] != -1)
        return win[mrg][len];
    win[mrg][len] = 0;
    bitset<300>ar;
    ar.reset();
    if(mrg == 0)  // ......
        for(int plc = 1; plc <= len; ++plc) // we can add to every position between 1 and len
            ar[solve(1, plc) ^ solve(1, len - plc + 1)] = 1;
    else
        if(mrg == 1) // .....X
            for(int plc = 1; plc < len-2; ++plc) // we can't add to positions len-2 and len-1(those would bring us instant lose)
                ar[solve(1, plc) ^ solve(2, len - plc + 1)] = 1;
        else /// X....X
            for(int plc = 4; plc < len-2; ++plc) // we can't add to positions 2, 3, len-2 and len-1(those would bring us instant lose)
                ar[solve(2, plc) ^ solve(2, len - plc + 1)] = 1;
    while(ar[win[mrg][len]] == 1)
        ++win[mrg][len];
    return win[mrg][len];
}
int main()
{

    #ifdef fisier
        ifstream f("input.in");
        ofstream g("output.out");
    #endif
    memset(win, -1, sizeof(win));
    win[1][3] = 0;
    win[2][3] = 1;
    win[0][3] = 1;
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    while(1)
    {
        int n;
        string s;
        cin >> n;
        if(n == 0)
            break;
        cin >> s;
        int ok = 0;
        for(int i = 0; i + 1 < n; ++i)
            if(s[i] == 'X' && s[i+1] == 'X')
                ok = 1;
        for(int i = 0; i + 2 < n; ++i)
            if(s[i] == 'X' && s[i+2] == 'X')
                ok = 1;
        if(ok)
            cout << "S\n";
        else
        {
            for(int i = 0; i < n; ++i)
                if(s[i] == 'X')
                {
                    int pz = i+1;
                    while(pz < n && s[pz] == '.')
                        ++pz;
                    if(pz == n)
                        ok ^= solve(1, n - i);
                    else
                        ok ^= solve(2, pz + 1 - i);
                    i = pz - 1;
                }
                else
                {
                    int pz = i+1;
                    while(pz < n && s[pz] == '.')
                        ++pz;
                    if(pz == n)
                        ok ^= solve(0, n - i);
                    else
                        ok ^= solve(1, pz + 1 - i);
                    i = pz - 1;
                }
            if(ok)
                cout << "S\n";
            else
                cout << "N\n";
        }
    }
    return 0;
}
